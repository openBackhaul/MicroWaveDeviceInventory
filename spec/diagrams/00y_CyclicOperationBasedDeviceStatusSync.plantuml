@startuml 00x_CyclicOperationBasedDeviceStatusSync
skinparam responseMessageBelowArrow true

title
PromptForEmbeddingCausesCyclicLoadingOfDeviceStatusFromController
PromptForEmbeddingCausesCyclicLoadingOfDeviceStatusMetadataFromElasticSearch
PromptForEmbeddingCausesCyclicLoadingOfDeviceTypeInfo
PromptForEmbeddingCausesUpdatingDeviceStatusMetadataInElasticSearch
end title

participant "RO" as ro
participant "MWDI://v1/embed-yourself" as mwdi
participant "ODL://{controllerInternalPathToMountPoint}?fields=\nnode(node-id;netconf-node-topology:\nconnection-status;schema-cache-directory)" as odlConnectionStatus
participant "MWDI://core-model-1-4:network-control-domain=cache/control-construct={mountName}\n?fields=logical-termination-point(layer-protocol(air-interface-2-0:air-interface-pac\n(air-interface-capability(type-of-equipment))))" as mwdiDevType
participant "ElasticSearch" as es

ro -> mwdi
activate mwdi

note over mwdi
Cyclic operation for 
updating the metadata table starts
end note

'get device info from Controller
note over mwdi
  <u>GetControllerDeviceInfo</u>
  get device info from Controller
end note
mwdi -> odlConnectionStatus
odlConnectionStatus -> mwdi: {list of-(mount-name, connection-status, schema-cache-directory)}

'get relevant MWDI metadata table info ElasticSearch
note over mwdi
  <u>GetMwdiMetadata</u>
  get device info metadata table
end note
mwdi -> es
es --> mwdi: {list-of(mount-name, connection-status, device-type)}

note over mwdi
<u>GetDeviceTypeFromCC</u>
compare devices from Controller & MWDI metadata table 
and determine target devices for which the device-type is 
fetched again from CC data with fields filter from <i>string-p-003</i>-profile

target devices are:
- all new devices from Controller
- all devices already present in metadata status table with
  - device-type = "unknown"
  - and GetControllerDeviceInfo.connection-status == "connected"

The retrieved rawDeviceTypeInfo must be mapped according to
regexMappingProfile <i>deviceTypeMapping</i>
The result is a list of {(mount-name, mapped-device-type)}
end note

mwdi -> mwdiDevType: {mount-name}
mwdiDevType --> mwdi: {rawDeviceTypeInfo}

note over mwdi
<u>UpdateMetadataTable</u>:
compare devices from Controller & MWDI metadata table and
update the metadata table accordingly:
- add new devices from Controller
- update device connection-status if necessary 
  (and schema-cache-directory)
- delete devices with connection-status!=connected 
  if retention period has been exceeded
end note

mwdi -> es: {list-of(mount-name, connection-status, schema-cache-directory, mapped-device-type), updateAction}
deactivate mwdi

@enduml